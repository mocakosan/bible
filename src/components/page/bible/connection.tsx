import Clipboard from "@react-native-clipboard/clipboard";
import { useIsFocused } from "@react-navigation/native";
import { useCallback, useLayoutEffect, useRef, useState, useEffect } from "react";
import { Platform, Share, View } from "react-native";
import { FloatingAction } from "react-native-floating-action";
import { Toast } from "react-native-toast-message/lib/src/Toast";
import { useDispatch, useSelector } from "react-redux";
import useSWR from "swr";
import TrackPlayer, { Event, State, useTrackPlayerEvents } from 'react-native-track-player';
import { bFloating, gFloating } from "../../../constant/global";
import { useNativeNavigation } from "../../../hooks";
import useWebview from "../../../hooks/webview/useWebview";
import {
    bibleSelectSlice,
    bibleTextSlice,
    illdocSelectSlice,
} from "../../../provider/redux/slice";
import { BibleNewDB, bibleSetting, color, fetchSql, defineSQL } from "../../../utils";
import { BibleStep } from "../../../utils/define";
import { defaultStorage } from "../../../utils/mmkv";
import { useBibleReading } from "../../../utils/useBibleReading";
import FooterLayout from "../../layout/footer/footer";
import IllDocPlayFooterLayout from "../../layout/footer/illDocPlayFooter";
import IllDocBibleHeaderLayout from "../../layout/header/illDocBibleHeader";
import BookLightModal from "../../modal/bookLightModal";
import BookMarkModal from "../../modal/bookMarkModal";
import { MalsumNoteModal } from "../../modal/note";
import BibleList from "../../section/bibleList";
import BibleConectionSubPage from "./_side/bible_conec";
import OtherPage from "./_side/other";
import React from "react";
import BibleReadingList from "../../section/bibleReadingList";

export default function BibleConectionScreen() {
    const dispatch = useDispatch();
    const isFocused = useIsFocused();
    const [sound, setSound] = useState(false);
    const [isPlaying, setIsPlaying] = useState(false);
    const [autoPlay, setAutoPlay] = useState<boolean>(false);
    const { navigation } = useNativeNavigation();
    const book = defaultStorage.getNumber("bible_book_connec") ?? 1;
    const jang = defaultStorage.getNumber("bible_jang_connec") ?? 1;
    const audioPlayerRef = useRef(null);
    const { loadPlan, markChapterAsRead, isChapterReadSync } = useBibleReading();

    // ÏûêÎèô ÏßÑÌñâ Í¥ÄÎ†® ÏÉÅÌÉú Ï∂îÍ∞Ä
    const [isAutoProgressEnabled, setIsAutoProgressEnabled] = useState(false);
    const [isAutoProcessing, setIsAutoProcessing] = useState(false);
    const autoProgressTimeoutRef = useRef<NodeJS.Timeout | null>(null);

    const {
        markChapterAsRead: markChapterAsReadHook,
        isChapterReadSync: isChapterReadSyncHook,
        planData,
        updateReadingTableCache,
        forceRefresh,  // Í∏∞Ï°¥
        registerGlobalRefreshCallback,  // üÜï Ï∂îÍ∞Ä
        unregisterGlobalRefreshCallback
    } = useBibleReading();

    const handleGlobalRefresh = useCallback(() => {
        console.log('üîÑ BibleConectionScreen Ï†ÑÏó≠ ÏÉàÎ°úÍ≥†Ïπ® Ïã§Ìñâ');

        // ÌòÑÏû¨ ÌéòÏù¥ÏßÄ Îç∞Ïù¥ÌÑ∞ ÏÉàÎ°úÍ≥†Ïπ®
        handleUpdateData();

        // Ï∂îÍ∞ÄÏ†ÅÏù∏ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä ÌïÑÏöîÌïòÎã§Î©¥ Ïó¨Í∏∞Ïóê Ï∂îÍ∞Ä
    }, [handleUpdateData]);

    useEffect(() => {
        console.log('üîÑ BibleConectionScreen Ï†ÑÏó≠ ÏÉàÎ°úÍ≥†Ïπ® ÏΩúÎ∞± Îì±Î°ù');
        registerGlobalRefreshCallback(handleGlobalRefresh);

        return () => {
            console.log('üîÑ BibleConectionScreen Ï†ÑÏó≠ ÏÉàÎ°úÍ≥†Ïπ® ÏΩúÎ∞± Ìï¥Ï†ú');
            unregisterGlobalRefreshCallback();
        };
    }, [registerGlobalRefreshCallback, unregisterGlobalRefreshCallback, handleGlobalRefresh]);

    // Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏ Ïãú ÏûêÎèô ÏßÑÌñâ Í∏∞Îä• Í∏∞Î≥∏ ÌôúÏÑ±Ìôî
    useEffect(() => {
        setIsAutoProgressEnabled(true);
        saveAutoProgressSetting(true);
    }, []);

    dispatch(illdocSelectSlice.actions.changePage({ book, jang }));
    const BOOK = useSelector(
        (state: any) => state.illDoc.book,
        (left, right) => left.book !== right.book
    );
    const JANG = useSelector(
        (state: any) => state.illDoc.jang,
        (left, right) => left.jang !== right.jang
    );

    const selectSql = `SELECT type, color, jul FROM 'bible_setting'
                       WHERE book = ${BOOK} and jang = ${JANG}`;

    const bibleName = `${BibleStep?.[BOOK - 1]?.name} ${JANG}Ïû•` ?? "";

    const fetcher = async (url: string) => {
        const data = await fetchSql(bibleSetting, url, []);
        return data;
    };

    const { data: markData, mutate } = useSWR(selectSql, fetcher);

    const handleUpdateData = useCallback(async () => {
        const data = await fetchSql(bibleSetting, selectSql, []);
        return mutate(selectSql, data);
    }, [BOOK, JANG]);

    const handleReadStatusChange = useCallback((book: number, chapter: number, isRead: boolean) => {
        handleUpdateData();
        loadPlan();
    }, [handleUpdateData, loadPlan]);

    // üî• ÏïàÏ†ÑÌïú markCurrentChapterAsRead Ìï®ÏàòÎ°ú ÍµêÏ≤¥
    const markCurrentChapterAsRead = useCallback(async () => {
        try {
            console.log(`üìù Connection: Marking chapter ${BOOK}:${JANG} as read`);

            // üî• Í∞ÄÏû• ÏïàÏ†ÑÌïú Î∞©Î≤ï: ÏßÅÏ†ë SQLite ÏóÖÎç∞Ïù¥Ìä∏
            const settingUpdateSql = `UPDATE reading_table SET read = ?, time = ? WHERE book = ? AND jang = ?`;
            const settingInsertSql = `INSERT OR REPLACE INTO reading_table (book, jang, read, time) VALUES (?, ?, ?, ?)`;

            try {
                // Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏
                const checkSql = `SELECT read FROM reading_table WHERE book = ? AND jang = ?`;
                const result = await fetchSql(bibleSetting, checkSql, [BOOK, JANG]);

                const currentTime = new Date().toISOString();

                if (result && result.length > 0) {
                    // Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
                    await fetchSql(bibleSetting, settingUpdateSql, ['TRUE', currentTime, BOOK, JANG]);
                    console.log('‚úÖ Connection: Updated existing reading record');
                } else {
                    // ÏÉà Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ
                    await fetchSql(bibleSetting, settingInsertSql, [BOOK, JANG, 'TRUE', currentTime]);
                    console.log('‚úÖ Connection: Created new reading record');
                }

            } catch (sqlError) {
                console.error('SQLite Ïò§Î•ò, ÎåÄÏ≤¥ Î∞©Î≤ï ÏãúÎèÑ:', sqlError);

                // üî• fallback: Îçî Í∞ÑÎã®Ìïú Î∞©Î≤ï
                const simpleSql = `INSERT OR REPLACE INTO reading_table (book, jang, read, time) VALUES (${BOOK}, ${JANG}, 'TRUE', '${new Date().toISOString()}')`;
                await fetchSql(bibleSetting, simpleSql, []);
                console.log('‚úÖ Connection: Fallback insert completed');
            }

            // üî• 2. Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏ (ÏïàÏ†ÑÌïòÍ≤å)
            try {
                if (typeof updateReadingTableCache === 'function') {
                    updateReadingTableCache(BOOK, JANG, true);
                    console.log('‚úÖ Connection: Updated reading table cache');
                }
            } catch (cacheError) {
                console.warn('Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå® (Î¨¥Ïãú Í∞ÄÎä•):', cacheError);
            }

            // üî• 3. ÏùºÎèÖ Í≥ÑÌöç Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ (ÏïàÏ†ÑÌïòÍ≤å)
            try {
                if (planData && typeof markChapterAsReadHook === 'function') {
                    await markChapterAsReadHook(BOOK, JANG);
                    console.log('‚úÖ Connection: Updated plan data');
                }
            } catch (planError) {
                console.warn('Í≥ÑÌöç Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå® (Î¨¥Ïãú Í∞ÄÎä•):', planError);
            }

            // üî• 4. Ï∂îÍ∞Ä ÎèôÍ∏∞Ìôî (ÏïàÏ†ÑÌïòÍ≤å)
            try {
                // Ï∂îÍ∞ÄÏ†ÅÏù∏ Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏Î°ú ÌôïÏã§Ìïú ÎèôÍ∏∞Ìôî
                setTimeout(() => {
                    if (typeof updateReadingTableCache === 'function') {
                        updateReadingTableCache(BOOK, JANG, true);
                        console.log('üîÑ Connection: Additional cache update for sync');
                    }
                }, 100);

                setTimeout(() => {
                    if (typeof updateReadingTableCache === 'function') {
                        updateReadingTableCache(BOOK, JANG, true);
                        console.log('üîÑ Connection: Final cache update for sync');
                    }
                }, 300);

                // ÏÉÅÏúÑ Ïª¥Ìè¨ÎÑåÌä∏ ÏïåÎ¶º
                if (typeof handleReadStatusChange === 'function') {
                    handleReadStatusChange(BOOK, JANG, true);
                    console.log('‚úÖ Connection: Notified parent component');
                }
            } catch (syncError) {
                console.warn('ÎèôÍ∏∞Ìôî ÏûëÏóÖ ÏùºÎ∂Ä Ïã§Ìå® (Î¨¥Ïãú Í∞ÄÎä•):', syncError);
            }

            console.log(`‚úÖ Connection: Successfully marked chapter ${BOOK}:${JANG} as read`);
            return true;

        } catch (error) {
            console.error('‚ùå Connection: Error marking chapter as read:', error);

            // üî• ÏµúÌõÑÏùò ÏàòÎã®: Í∞ÄÏû• Í∞ÑÎã®Ìïú Î∞©Î≤ï
            try {
                console.log('üîÑ Connection: Attempting final fallback method');
                const fallbackSql = `UPDATE reading_table SET read = 'TRUE' WHERE book = ${BOOK} AND jang = ${JANG}`;
                await fetchSql(bibleSetting, fallbackSql, []);
                console.log('‚úÖ Connection: Fallback method succeeded');
                return true;
            } catch (fallbackError) {
                console.error('‚ùå Connection: All methods failed:', fallbackError);
                throw error;
            }
        }
    }, [BOOK, JANG, planData, markChapterAsReadHook, updateReadingTableCache, handleReadStatusChange]);

    // üî• ÏûêÎèô ÏßÑÌñâ Ìï®Ïàò Í∞úÏÑ†
    const handleAutoProgress = useCallback(async () => {
        // Ï§ëÎ≥µ Ïã§Ìñâ Î∞©ÏßÄ
        if (isAutoProcessing) {
            console.log('‚ö†Ô∏è Connection: Auto progress already in progress, skipping');
            return;
        }

        console.log(`üöÄ Connection: Starting auto progress for ${BOOK}:${JANG}`);
        setIsAutoProcessing(true);

        try {
            // 1. Ïû¨ÏÉù ÏôÑÎ£å ÏïåÎ¶º (Ï¶âÏãú ÌëúÏãú)
            // Ïó¨Í∏∞Ïóê Í∏∞Ï°¥ ÏïåÎ¶º ÏΩîÎìúÍ∞Ä ÏûàÎã§Î©¥ Ïú†ÏßÄ

            // 2. ÏßßÏùÄ ÎåÄÍ∏∞ (ÏÇ¨Ïö©ÏûêÍ∞Ä Î©îÏãúÏßÄÎ•º ÌôïÏù∏Ìï† Ïàò ÏûàÎèÑÎ°ù)
            await new Promise(resolve => setTimeout(resolve, 800));

            // 3. ÌòÑÏû¨ Ïû•ÏùÑ ÏùΩÏóàÏùåÏúºÎ°ú ÏûêÎèô Ï≤¥ÌÅ¨ (ÏïàÏ†ÑÌïú Ìï®Ïàò ÏÇ¨Ïö©)
            console.log(`üìñ Connection: Marking chapter ${BOOK}:${JANG} as read`);

            const success = await markCurrentChapterAsRead();

            if (!success) {
                throw new Error('Failed to mark chapter as read');
            }

            // 4. Ï∂îÍ∞Ä ÎåÄÍ∏∞ Î∞è ÏÉÅÌÉú Ïû¨ÌôïÏù∏ (ÎèôÍ∏∞Ìôî Î≥¥Ïû•)
            await new Promise(resolve => setTimeout(resolve, 200));

            // 5. Ï∂îÍ∞Ä ÎåÄÍ∏∞ ÌõÑ Îã§Ïùå Ïû•ÏúºÎ°ú Ïù¥Îèô
            await new Promise(resolve => setTimeout(resolve, 1000));

            console.log(`‚è≠Ô∏è Connection: Moving to next chapter from ${BOOK}:${JANG}`);
            onPressNext(JANG);

            console.log('‚úÖ Connection: Auto progress completed successfully');

        } catch (error) {
            console.error('‚ùå Connection: Auto progress error:', error);

            // üî• ÏÇ¨Ïö©Ïûê ÏπúÌôîÏ†ÅÏù∏ Ïò§Î•ò Î©îÏãúÏßÄÎ°ú Î≥ÄÍ≤Ω
            Toast.show({
                type: "info",
                text1: "ÏûêÎèô ÏßÑÌñâ ÏùºÏãú Ï§ëÎã®",
                text2: "ÏàòÎèôÏúºÎ°ú ÏùΩÍ∏∞ ÏôÑÎ£åÎ•º Ï≤¥ÌÅ¨Ìï¥Ï£ºÏÑ∏Ïöî.",
                visibilityTime: 2500,
                position: "top",
            });
        } finally {
            // Ï≤òÎ¶¨ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
            setIsAutoProcessing(false);
            if (autoProgressTimeoutRef.current) {
                clearTimeout(autoProgressTimeoutRef.current);
                autoProgressTimeoutRef.current = null;
            }
            console.log('üîÑ Connection: Resetting auto progress states');
        }
    }, [BOOK, JANG, isAutoProcessing, markCurrentChapterAsRead, onPressNext]);

    // üî• Ï∂îÍ∞Ä ÏïàÏ†Ñ Ïû•Ïπò
    const safeHandleAutoProgress = useCallback(async () => {
        try {
            await handleAutoProgress();
        } catch (error) {
            console.error('‚ùå ConectionContainer: Auto progress error:', error);
            console.log('üîÑ ConectionContainer: Resetting auto progress states');

            // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
            setIsAutoProcessing(false);
            if (autoProgressTimeoutRef.current) {
                clearTimeout(autoProgressTimeoutRef.current);
                autoProgressTimeoutRef.current = null;
            }
        }
    }, [handleAutoProgress]);

    // TrackPlayer Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà - Ïò§ÎîîÏò§ Ïû¨ÏÉù ÏôÑÎ£å Í∞êÏßÄ
    useTrackPlayerEvents([
        Event.PlaybackQueueEnded,
        Event.PlaybackState,
        Event.PlaybackTrackChanged
    ], async (event) => {
        console.log('üéµ TrackPlayer Event:', event.type, 'AutoProgress:', isAutoProgressEnabled);

        // ÏûêÎèô ÏßÑÌñâÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÍ±∞ÎÇò Ïù¥ÎØ∏ Ï≤òÎ¶¨ Ï§ëÏù¥Î©¥ Î¶¨ÌÑ¥
        if (!isAutoProgressEnabled || isAutoProcessing || !sound) {
            console.log('‚ùå Auto progress skipped:', {
                enabled: isAutoProgressEnabled,
                processing: isAutoProcessing,
                sound: sound
            });
            return;
        }

        // Ïû¨ÏÉù ÏôÑÎ£å Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
        if (event.type === Event.PlaybackQueueEnded) {
            console.log('üèÅ Audio playback completed - starting auto progress');
            await safeHandleAutoProgress(); // üî• ÏïàÏ†ÑÌïú Ìï®Ïàò ÏÇ¨Ïö©
        }

        // Ïû¨ÏÉù ÏÉÅÌÉúÍ∞Ä Ï¢ÖÎ£åÎ°ú Î≥ÄÍ≤ΩÎêú Í≤ΩÏö∞ÎèÑ Ï≤òÎ¶¨
        else if (event.type === Event.PlaybackState && event.state === State.Ended) {
            console.log('üéØ Audio state ended - starting auto progress');
            // ÏïΩÍ∞ÑÏùò ÏßÄÏó∞ÏùÑ ÎëêÍ≥† Ïã§Ìñâ (Ï§ëÎ≥µ Ìò∏Ï∂ú Î∞©ÏßÄ)
            if (autoProgressTimeoutRef.current) {
                clearTimeout(autoProgressTimeoutRef.current);
            }
            autoProgressTimeoutRef.current = setTimeout(async () => {
                await safeHandleAutoProgress(); // üî• ÏïàÏ†ÑÌïú Ìï®Ïàò ÏÇ¨Ïö©
            }, 500);
        }
    });

    // Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
    useEffect(() => {
        return () => {
            if (autoProgressTimeoutRef.current) {
                clearTimeout(autoProgressTimeoutRef.current);
            }
        };
    }, []);

    const onPressforward = useCallback(
        async (jang: number) => {
            const curJang = jang - 1;

            if (curJang === 0) {
                if (BOOK > 1) {
                    defaultStorage.set("bible_book_connec", BOOK - 1);
                    defaultStorage.set("bible_jang_connec", BibleStep[BOOK - 2].count);
                    dispatch(
                        illdocSelectSlice.actions.changePage({
                            book: BOOK - 1,
                            jang: BibleStep[BOOK - 2].count,
                        })
                    );
                }
            } else {
                defaultStorage.set("bible_jang_connec", curJang);
                dispatch(
                    illdocSelectSlice.actions.changePage({
                        book: BOOK,
                        jang: curJang,
                    })
                );
            }

            if (sound) {
                handleUpdateData();
                setAutoPlay(true);
                setIsPlaying(false);
            }

            dispatch(bibleTextSlice.actions.reset());
        },
        [sound, BOOK, JANG]
    );

    const onPressNext = useCallback(
        (jang: number) => {
            const curJang = jang + 1;
            const totalJang = BibleStep[BOOK - 1].count;

            if (curJang > totalJang) {
                if (BOOK === 66) {
                    Toast.show({
                        type: "success",
                        text1: "üéâ ÏÑ±Í≤Ω Ï†ÑÏ≤¥ ÏôÑÎèÖÏùÑ Ï∂ïÌïòÌï©ÎãàÎã§!",
                        text2: "ÏÑ§Ï†ï ÌôîÎ©¥ÏúºÎ°ú Ïù¥ÎèôÌï©ÎãàÎã§.",
                        visibilityTime: 3000,
                    });
                    navigation.navigate("IllDocSettingScreen", {});
                    return;
                } else {
                    defaultStorage.set("bible_book_connec", BOOK + 1);
                    defaultStorage.set("bible_jang_connec", 1);
                    dispatch(
                        illdocSelectSlice.actions.changePage({
                            book: BOOK + 1,
                            jang: 1,
                        })
                    );
                }
            } else {
                defaultStorage.set("bible_jang_connec", curJang);
                dispatch(
                    illdocSelectSlice.actions.changePage({
                        book: BOOK,
                        jang: curJang,
                    })
                );
            }

            handleUpdateData();
            dispatch(bibleTextSlice.actions.reset());

            if (sound && audioPlayerRef.current) {
                setTimeout(() => {
                    audioPlayerRef.current.playCurrentPageAudio();
                }, 500);
            }
        },
        [sound, BOOK, JANG, handleUpdateData, navigation]
    );

    const [menuIndex, setMenuIndex] = useState<number>(0);
    const onMenuPress = useCallback(
        (index: number) => {
            setMenuIndex(index);
        },
        [menuIndex]
    );

    const MenusRenderIndex = useCallback(() => {
        switch (menuIndex) {
            case 1:
                return `${process.env.WEB_WIEW_BASE_URL}/bible/study?book=${BOOK}&jang=${JANG}`;
            case 2:
                return `${process.env.WEB_WIEW_BASE_URL}/bible/note?book=${BOOK}&jang=${JANG}`;
            case 3:
                return `${process.env.WEB_WIEW_BASE_URL}/bible/mook?book=${BOOK}&jang=${JANG}`;
            case 4:
                return `${process.env.WEB_WIEW_BASE_URL}/bible/qa?book=${BOOK}&jang=${JANG}`;
            case 5:
                return `${process.env.WEB_WIEW_BASE_URL}/bible/photo?book=${BOOK}&jang=${JANG}`;
            default:
                return "";
        }
    }, [menuIndex, BOOK, JANG]);

    useLayoutEffect(() => {
        if (isFocused) {
            handleUpdateData();
        }
    }, [isFocused]);

    const { WebView, isNetWork } = useWebview({
        uri: "https://bible25frontend.givemeprice.co.kr/bible",
    });

    return (
        <>
            <IllDocBibleHeaderLayout
                {...{
                    open: sound,
                    setOpen: setSound,
                    name: bibleName,
                    darkmode: false,
                }}
            />

            {menuIndex === 0 ? (
                <>
                    <BibleConectionSubPage
                        {...{
                            BOOK,
                            JANG,
                            markData,
                            onPressforward,
                            onPressNext,
                            isPlaying,
                            setIsPlaying,
                            autoPlay,
                            setAutoPlay,
                            onReadStatusChange: handleReadStatusChange,
                            isAutoProgressEnabled,
                            sound,
                        }}
                    />
                    {!sound && <BibleReadingList vector={false} menuIndex={menuIndex} onPress={onMenuPress} />}
                    <IllDocPlayFooterLayout
                        ref={audioPlayerRef}
                        onTrigger={handleUpdateData}
                        openSound={sound}
                    />
                </>
            ) : (
                <>
                    <OtherPage uri={MenusRenderIndex()} />
                    <FooterLayout />
                </>
            )}
            <FloatingActionContainer
                BOOK={BOOK}
                JANG={JANG}
                handleUpdateData={handleUpdateData}
            />
            <View style={{ width: 0, display: "none" }}>{WebView}</View>
        </>
    );
}

// ÏÑ§Ï†ï Ï†ÄÏû•/Î°úÎìú Ïú†Ìã∏ Ìï®ÏàòÎì§
const saveAutoProgressSetting = (enabled: boolean) => {
    defaultStorage.set('auto_progress_enabled', enabled);
};

const getAutoProgressSetting = (): boolean => {
    return defaultStorage.getBoolean('auto_progress_enabled') ?? false;
};

// FloatingActionContainerÏôÄ ÎÇòÎ®∏ÏßÄ Ìï®ÏàòÎì§ÏùÄ Í∏∞Ï°¥Í≥º ÎèôÏùº
const FloatingActionContainer = ({ BOOK, JANG, handleUpdateData }: any) => {
    const fontStyle = JSON.parse(defaultStorage.getString("fontStyle") ?? "");
    const dispatch = useDispatch();
    const [open, setOpen] = useState(0);
    const isFloating = useSelector(
        (state: any) => state.bibleMenu.firstRead,
        (left, right) => left.firstRead !== right.firstRead
    );
    const totaljul = useSelector(
        (state: any) => state.bibleMenu.jul,
        (left, right) => left.jul !== right.jul
    );

    return (
        <>
            <MalsumNoteModal
                open={open}
                close={() => setOpen(0)}
                BOOK={BOOK}
                JANG={JANG}
            />
            <BookMarkModal
                BOOK={BOOK}
                JANG={JANG}
                markData={totaljul}
                isOpen={open}
                onClose={() => setOpen(0)}
                onTrigger={() => handleUpdateData()}
            />
            <BookLightModal
                BOOK={BOOK}
                JANG={JANG}
                markData={totaljul}
                isOpen={open}
                onClose={() => setOpen(0)}
                onTrigger={() => handleUpdateData()}
            />
            {isFloating && (
                <FloatingAction
                    position="right"
                    distanceToEdge={{ vertical: 140, horizontal: 10 }}
                    showBackground={false}
                    color={
                        fontStyle.julColor === color.bible
                            ? "rgba(42,193,188,0.8)"
                            : "rgba(100,100,100,0.6)"
                    }
                    buttonSize={45}
                    actions={fontStyle.julColor === color.bible ? gFloating : bFloating}
                    onPressItem={(text) => {
                        usebibleFloating(
                            text as string,
                            BOOK,
                            JANG,
                            totaljul,
                            dispatch,
                            setOpen
                        );
                    }}
                />
            )}
        </>
    );
};

const usebibleFloating = (
    text: string,
    book: any,
    jang: any,
    totaljul: any,
    dispatch: any,
    setOpen: any
) => {
    switch (text) {
        case "Î≥µÏÇ¨":
            onCopy(getBibleSettingData(book, jang, totaljul));
            return dispatch(bibleSelectSlice.actions.reset());
        case "Í≥µÏú†":
            onShare(getBibleSettingData(book, jang, totaljul));
            return dispatch(bibleSelectSlice.actions.reset());
        case "Î∂ÅÎßàÌÅ¨":
            return setOpen(1);
        case "ÌòïÍ¥ëÌéú":
            return setOpen(2);
        case "ÎßêÏîÄÎÖ∏Ìä∏":
            return setOpen(3);
        default:
            break;
    }
};

const getBibleSettingData = async (
    book: number,
    jang: number,
    totaljul: number[]
) => {
    let sqlQuery;

    const mmkv = defaultStorage.getString("bibleNames");

    if (mmkv) {
        sqlQuery = `SELECT jul, content FROM bible_${book} WHERE  type in(${JSON.parse(
                mmkv
        )
                .map((val: string) => (val = "'" + val + "'"))
                .join(",")}) and jang = ${jang} and jul in (${totaljul.join(
                ","
        )}) order by jul;`;
    } else {
        sqlQuery = `SELECT jul, content FROM bible_${book} WHERE  type = "nkrv" and jang = ${jang} and jul in (${totaljul.join(
                ","
        )}) order by jul;`;
    }

    try {
        const result = await fetchSql(BibleNewDB, sqlQuery, []);
        return String(result.map(({ jul, content }: any) => `${jul} ${content}`));
    } catch (err) {
        return console.log(err);
    }
};

const onCopy = async (txt: string | any) => {
    try {
        Clipboard.setString(`${await txt}`);
        return Toast.show({
            type: "success",
            text1: "Î≥µÏÇ¨ÌñàÏäµÎãàÎã§.",
        });
    } catch (error) {
        return Toast.show({
            type: "error",
            text1: "Ïã§Ìå®ÌñàÏäµÎãàÎã§.",
        });
    }
};

const onShare = async (txt: string | any) => {
    Share.share({
        message:
            Platform.OS === "ios"
                ? `${await txt}
      https://apps.apple.com/kr/app/Î∞îÏù¥Î∏î25/id814929019`
                : `${await txt}
      https://play.google.com/store/search?q=Î∞îÏù¥Î∏î25&c=apps&hl=ko-KR
      `,
    });
};
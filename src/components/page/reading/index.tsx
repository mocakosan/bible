// src/components/page/reading/index.tsx
// ÏãúÍ∞Ñ Í∏∞Î∞ò Í≥ÑÏÇ∞ ÏßÄÏõêÏùÑ ÏúÑÌïú Ï†ÑÏ≤¥ ÏàòÏ†ï ÏΩîÎìú

import {useFocusEffect, useIsFocused} from "@react-navigation/native";
import { useCallback, useEffect, useState } from "react";
import { bibleSetting, defineSQL, fetchSql } from "../../../utils";
import FooterLayout from "../../layout/footer/footer";
import New from "./_side/new";
import Old from "./_side/old";
import SettingSidePage from "./_side/setting";
import { Platform, View, StyleSheet } from "react-native";
import { Box, Text, VStack, HStack, Progress, Button, Badge, ScrollView } from "native-base";
import BannerAdMain from "../../../adforus/BannerAdMain";
import {
  loadBiblePlanData,
  calculateProgress,
  calculateMissedChapters,
  formatDate,
  deleteBiblePlanData,
  getTodayChapters,
  formatTime,
  formatDailyTarget, getCurrentDay
} from "../../../utils/biblePlanUtils";
import { useBaseStyle, useNativeNavigation } from "../../../hooks";
import { Alert } from "react-native";
import { Toast } from "react-native-toast-message/lib/src/Toast";
import { useBibleReading } from "../../../utils/useBibleReading";
import { defaultStorage } from "../../../utils/mmkv";
import Tabs from "../../layout/tab/tabs";
import BackHeaderLayout from "../../layout/header/backHeader";
import ProgressScreen from "../progs";
import dayjs from 'dayjs';

export default function ReadingBibleScreen() {
  const [menuIndex, setMenuIndex] = useState<number>(2);
  const [mark, setMark] = useState<any>(null);
  const [planData, setPlanData] = useState<any>(null);
  const [menuList, setMenuList] = useState<string[]>(["Íµ¨ÏïΩ", "Ïã†ÏïΩ", "ÏÑ§Ï†ï"]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [forceUpdateKey, setForceUpdateKey] = useState<number>(0);
  const isFocused = useIsFocused();
  const { color } = useBaseStyle();
  const { navigation } = useNativeNavigation();

  const {
    registerGlobalRefreshCallback,
    unregisterGlobalRefreshCallback
  } = useBibleReading(mark);

  const safeMenuList = menuList && menuList.length > 0 ? menuList : ["Íµ¨ÏïΩ", "Ïã†ÏïΩ", "ÏÑ§Ï†ï"];

  const settingSelectSql = `${defineSQL(["*"], "SELECT", "reading_table", {
    WHERE: { read: "?" }
  })}`;

  const getPlanTypeName = useCallback((planType: string): string => {
    switch (planType) {
      case 'full_bible': return 'ÏÑ±Í≤Ω';
      case 'old_testament': return 'Íµ¨ÏïΩ';
      case 'new_testament': return 'Ïã†ÏïΩ';
      case 'pentateuch': return 'Î™®ÏÑ∏Ïò§Í≤Ω';
      case 'psalms': return 'ÏãúÌé∏';
      default: return 'ÏÑ±Í≤Ω';
    }
  }, []);

  const getPlanTypeDescription = useCallback((planType: string): string => {
    switch (planType) {
      case 'full_bible':
        return 'Ï∞ΩÏÑ∏Í∏∞ 1Ïû• ~ ÏöîÌïúÍ≥ÑÏãúÎ°ù 22Ïû•';
      case 'old_testament':
        return 'Ï∞ΩÏÑ∏Í∏∞ 1Ïû• ~ ÎßêÎùºÍ∏∞ 4Ïû•';
      case 'new_testament':
        return 'ÎßàÌÉúÎ≥µÏùå 1Ïû• ~ ÏöîÌïúÍ≥ÑÏãúÎ°ù 22Ïû•';
      case 'pentateuch':
        return 'Ï∞ΩÏÑ∏Í∏∞ 1Ïû• ~ Ïã†Î™ÖÍ∏∞ 34Ïû•';
      case 'psalms':
        return 'ÏãúÌé∏ 1Ïû• ~ ÏãúÌé∏ 150Ïû•';
      default:
        return 'Ï∞ΩÏÑ∏Í∏∞ 1Ïû• ~ ÏöîÌïúÍ≥ÑÏãúÎ°ù 22Ïû•';
    }
  }, []);

  const loadReadingState = useCallback(async () => {
    try {
      setIsLoading(true);
      console.log('üìö ÏùΩÍ∏∞ ÏÉÅÌÉú Î°úÎìú ÏãúÏûë');

      const results = await fetchSql(
          bibleSetting,
          settingSelectSql,
          ['TRUE']
      );

      if (results && Array.isArray(results)) {
        setMark(results);
        console.log('üìö ÏùΩÍ∏∞ ÏÉÅÌÉú Î°úÎìú ÏôÑÎ£å:', results.length, 'Í∞ú Ìï≠Î™©');
      } else {
        setMark([]);
        console.log('üìö ÏùΩÍ∏∞ ÏÉÅÌÉú ÏóÜÏùå');
      }
    } catch (error) {
      console.error('üìö ÏùΩÍ∏∞ ÏÉÅÌÉú Î°úÎìú Ïò§Î•ò:', error);
      setMark([]);
    } finally {
      setIsLoading(false);
    }
  }, [settingSelectSql]);

  const updateMenuAndData = useCallback(() => {
    try {
      const existingPlan = loadBiblePlanData();

      if (existingPlan) {
        setPlanData(existingPlan);

        let newMenuList: string[] = ["Íµ¨ÏïΩ", "Ïã†ÏïΩ", "ÏÑ§Ï†ï"];

        switch (existingPlan.planType) {
          case 'full_bible':
            newMenuList = ["ÏÑ±Í≤Ω", "ÏßÑÎèÑ"];
            break;
          case 'old_testament':
            newMenuList = ["Íµ¨ÏïΩ", "ÏßÑÎèÑ"];
            break;
          case 'new_testament':
            newMenuList = ["Ïã†ÏïΩ", "ÏßÑÎèÑ"];
            break;
          case 'pentateuch':
            newMenuList = ["Î™®ÏÑ∏Ïò§Í≤Ω", "ÏßÑÎèÑ"];
            break;
          case 'psalms':
            newMenuList = ["ÏãúÌé∏", "ÏßÑÎèÑ"];
            break;
          default:
            newMenuList = ["Íµ¨ÏïΩ", "Ïã†ÏïΩ", "ÏÑ§Ï†ï"];
        }

        setMenuList(newMenuList);
        setMenuIndex(0);
        console.log('ÏùºÎèÖ Î©îÎâ¥ ÏóÖÎç∞Ïù¥Ìä∏:', newMenuList);
      } else {
        setPlanData(null);
        setMenuList(["Íµ¨ÏïΩ", "Ïã†ÏïΩ", "ÏÑ§Ï†ï"]);
        setMenuIndex(2);
        console.log('ÏùºÎèÖ ÏóÜÏùå - Í∏∞Î≥∏ Î©îÎâ¥ ÏÑ§Ï†ï');
      }
    } catch (error) {
      console.error('ÏùºÎèÖ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò:', error);
      setPlanData(null);
      setMenuList(["Íµ¨ÏïΩ", "Ïã†ÏïΩ", "ÏÑ§Ï†ï"]);
      setMenuIndex(2);
    }
  }, []);

  const handleGlobalRefresh = useCallback(() => {
    console.log('üîÑ ReadingBibleScreen Ï†ÑÏó≠ ÏÉàÎ°úÍ≥†Ïπ® Ïã§Ìñâ');
    setForceUpdateKey(prev => prev + 1);
    loadReadingState();
    updateMenuAndData();
  }, [loadReadingState, updateMenuAndData]);

  const handleMenuChange = useCallback((index: number) => {
    setMenuIndex(index);
    const currentMenuName = safeMenuList[index];
    console.log(`Î©îÎâ¥ Î≥ÄÍ≤Ω: ${currentMenuName} (Ïù∏Îç±Ïä§: ${index})`);
  }, [safeMenuList]);

  const handleChangeUpdateData = useCallback(async (targetTabIndex?: number) => {
    try {
      setIsLoading(true);
      await loadReadingState();
      updateMenuAndData();
      setForceUpdateKey(prev => prev + 1);

      if (typeof targetTabIndex === 'number' && targetTabIndex >= 0) {
        setMenuIndex(targetTabIndex);
        console.log(`ÌÉ≠ Ïù¥Îèô ÏöîÏ≤≠: Ïù∏Îç±Ïä§ ${targetTabIndex}`);
      }
    } catch (error) {
      console.error('Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò:', error);
      Toast.show({
        type: 'error',
        text1: 'Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§'
      });
    } finally {
      setIsLoading(false);
    }
  }, [loadReadingState, updateMenuAndData]);

  const handleDirectReset = useCallback(async () => {
    try {
      console.log('=== ReadingBibleScreen ÏßÅÏ†ë Ï¥àÍ∏∞Ìôî ÏãúÏûë ===');

      Toast.show({
        type: 'info',
        text1: 'Ï¥àÍ∏∞Ìôî Ï§ë...',
        text2: 'Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî',
        autoHide: false
      });

      try {
        const allKeys = defaultStorage.getAllKeys();
        const keysToDelete = allKeys.filter(key =>
            key.startsWith('bible_') ||
            key.startsWith('reading_') ||
            key.includes('plan') ||
            key === 'calender' ||
            key === 'bible_reading_plan'
        );

        keysToDelete.forEach(key => {
          defaultStorage.delete(key);
          console.log('MMKV ÌÇ§ ÏÇ≠Ï†ú:', key);
        });
      } catch (mmkvError) {
        console.error('MMKV Ï†ïÎ¶¨ Ïò§Î•ò:', mmkvError);
      }

      try {
        const deleteSql = 'DELETE FROM reading_table';
        await fetchSql(bibleSetting, deleteSql, []);
        console.log('SQLite reading_table ÏÇ≠Ï†ú ÏôÑÎ£å');
      } catch (sqlError) {
        console.error('SQLite ÏÇ≠Ï†ú Ïò§Î•ò:', sqlError);
      }

      setPlanData(null);
      setMenuList(["Íµ¨ÏïΩ", "Ïã†ÏïΩ", "ÏÑ§Ï†ï"]);
      setMenuIndex(2);
      setForceUpdateKey(prev => prev + 1);

      await loadReadingState();
      updateMenuAndData();

      Toast.hide();
      Toast.show({
        type: 'success',
        text1: 'Ï¥àÍ∏∞Ìôî ÏôÑÎ£å',
        text2: 'Î™®Îì† Îç∞Ïù¥ÌÑ∞Í∞Ä Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§'
      });

      console.log('=== ReadingBibleScreen ÏßÅÏ†ë Ï¥àÍ∏∞Ìôî ÏôÑÎ£å ===');
    } catch (error) {
      console.error('ÏßÅÏ†ë Ï¥àÍ∏∞Ìôî Ïò§Î•ò:', error);
      Toast.hide();
      Toast.show({
        type: 'error',
        text1: 'Ï¥àÍ∏∞Ìôî Ïã§Ìå®',
        text2: 'Ï¥àÍ∏∞Ìôî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§'
      });
    }
  }, [loadReadingState, updateMenuAndData]);

  // üî• ÏàòÏ†ïÎêú ProgressView Ïª¥Ìè¨ÎÑåÌä∏ - ÏãúÍ∞Ñ Í∏∞Î∞ò Í≥ÑÏÇ∞ ÌÜµÌï©
  const ProgressView = useCallback(() => {
    if (!planData) {
      return <ProgressScreen key={`progress-${forceUpdateKey}`} />;
    }

    const progress = calculateProgress(planData);
    const missedCount = calculateMissedChapters(planData);
    const todayChapters = getTodayChapters(planData);

    const getDaysRemaining = () => {
      const endDate = new Date(planData.endDate || planData.targetDate);
      const today = new Date();
      const diffTime = endDate.getTime() - today.getTime();
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      return Math.max(0, diffDays);
    };

    const getStatusColor = (percentage: number) => {
      if (percentage >= 80) return '#4CAF50';
      if (percentage >= 60) return '#FF9800';
      return '#F44336';
    };

    // üî• ÏàòÏ†ï: getDailyTargetDisplay Ìï®ÏàòÎèÑ ÎèôÏùºÌïòÍ≤å ÏàòÏ†ï
    const getDailyTargetDisplay = () => {
      // ÏãúÍ∞Ñ Í∏∞Î∞ò Í≥ÑÌöçÏù¥Í≥† dailyPlanÏù¥ ÏûàÎäî Í≤ΩÏö∞
      if (planData.isTimeBasedCalculation && planData.dailyPlan && planData.dailyPlan.length > 0) {
        const currentDay = getCurrentDay(planData.startDate);
        const todayPlan = planData.dailyPlan.find((day: any) => day.day === currentDay);

        if (todayPlan) {
          return {
            chapters: todayPlan.actualChapterCount || todayPlan.chapters.length,
            time: todayPlan.formattedTime || `${todayPlan.totalMinutes}Î∂Ñ`,
            isTimeBase: true
          };
        }
      }

      // Í∏∞Î≥∏Í∞í
      const chapters = todayChapters.length || planData.chaptersPerDay || Math.ceil(planData.totalChapters / planData.totalDays);
      const minutes = planData.minutesPerDay || planData.targetMinutesPerDay || Math.round(planData.minutesPerDayExact) || Math.round(chapters * 4.5);

      return {
        chapters: chapters,
        time: `${minutes}Î∂Ñ`,
        isTimeBase: planData.isTimeBasedCalculation || false
      };
    };

    const dailyTarget = getDailyTargetDisplay();

    const handleResetPlan = () => {
      Alert.alert(
          'ÏùºÎèÖ Ï¥àÍ∏∞Ìôî',
          'ÌòÑÏû¨ ÏùºÎèÖ Í≥ÑÌöçÏùÑ Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå?\n\n‚ö†Ô∏è Ïù¥ ÏûëÏóÖÏùÄ ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§.',
          [
            { text: 'Ï∑®ÏÜå', style: 'cancel' },
            {
              text: 'Ï¥àÍ∏∞Ìôî',
              style: 'destructive',
              onPress: handleDirectReset
            }
          ]
      );
    };

    return (
        <ScrollView style={{ backgroundColor: color.white, flex: 1 }}>
          {/* ÏßÑÌñâÎ•† Ïπ¥Îìú */}
          <Box bg="white" mx={4} mt={4} p={4} borderRadius="md" shadow={1}>
            <VStack space={3}>
              <Text fontSize="22" fontWeight="600" color="#333">
                üìä ÏùºÎèÖ ÏßÑÌñâ ÌòÑÌô©
              </Text>

              <Box>
                <HStack justifyContent="space-between" mb={2}>
                  <Text fontSize="18" color="#666">
                    Ï†ÑÏ≤¥ ÏßÑÌñâÎ•†
                  </Text>
                  <Text fontSize="18" fontWeight="600" color={getStatusColor(progress.progressPercentage)}>
                    {progress.progressPercentage.toFixed(1)}%
                  </Text>
                </HStack>
                <Progress
                    value={progress.progressPercentage}
                    bg="#E0E0E0"
                    _filledTrack={{ bg: getStatusColor(progress.progressPercentage) }}
                    size="md"
                    borderRadius="full"
                />
              </Box>

              {/* ÏãúÍ∞Ñ Í∏∞Î∞òÏùº Îïå Ïò§Îäò ÏßÑÎèÑ ÌëúÏãú Í∞úÏÑ† */}
              {planData.isTimeBasedCalculation && todayChapters.length > 0 && (
                  <Box>
                    <HStack justifyContent="space-between" mb={2}>
                      <Text fontSize="18" color="#666">
                        Ïò§Îäò ÏßÑÎèÑ
                      </Text>
                      <Text fontSize="18" fontWeight="600" color="#4CAF50">
                        {progress.todayProgress ? `${progress.todayProgress.toFixed(1)}%` : '0%'}
                      </Text>
                    </HStack>
                    <Progress
                        value={progress.todayProgress || 0}
                        bg="#E0E0E0"
                        _filledTrack={{ bg: "#4CAF50" }}
                        size="sm"
                        borderRadius="full"
                    />
                    {progress.estimatedTimeToday && (
                        <Text fontSize="14" color="#666" mt={1}>
                          ÏòàÏÉÅ ÏãúÍ∞Ñ: {progress.estimatedTimeToday}
                        </Text>
                    )}
                  </Box>
              )}

              <HStack justifyContent="space-around" pt={2}>
                <VStack alignItems="center">
                  <Text fontSize="24" fontWeight="600" color="#37C4B9">
                    {progress.readChapters || 0}
                  </Text>
                  <Text fontSize="16" color="#666">
                    ÏùΩÏùÄ Ïû•
                  </Text>
                </VStack>
                <VStack alignItems="center">
                  <Text fontSize="24" fontWeight="600" color="#666">
                    {planData.totalChapters || 0}
                  </Text>
                  <Text fontSize="16" color="#666">
                    Ï†ÑÏ≤¥ Ïû•
                  </Text>
                </VStack>
                <VStack alignItems="center">
                  <Text fontSize="24" fontWeight="600" color="#F44336">
                    {missedCount || 0}
                  </Text>
                  <Text fontSize="16" color="#666">
                    ÎÜìÏπú Ïû•
                  </Text>
                </VStack>
              </HStack>
            </VStack>
          </Box>

          {/* ÏùºÏ†ï Ï†ïÎ≥¥ Ïπ¥Îìú - ÏãúÍ∞Ñ Í∏∞Î∞ò Í∞úÏÑ† */}
          <Box bg="white" mx={4} mt={4} p={4} borderRadius="md" shadow={1}>
            <VStack space={3}>
              <Text fontSize="22" fontWeight="600" color="#333">
                üìÖ ÏùºÎèÖ Ï†ïÎ≥¥
              </Text>
              <VStack space={2}>
                <HStack justifyContent="space-between">
                  <Text fontSize="18" color="#666">Í≥ÑÌöç Ïú†Ìòï</Text>
                  <Text fontSize="18" fontWeight="500">{getPlanTypeName(planData.planType)}</Text>
                </HStack>

                {/* ÌïòÎ£® Î™©Ìëú ÌëúÏãú Í∞úÏÑ† */}
                <HStack justifyContent="space-between">
                  <Text fontSize="18" color="#666">Ïò§Îäò Î™©Ìëú</Text>
                  <Text fontSize="18" fontWeight="500">
                    {dailyTarget.chapters}Ïû• / {dailyTarget.time.toString().split('.')[0].replace('', '')}
                  </Text>
                </HStack>

                {/* ÏßÑÌñâ ÏÉÅÌÉú Í∞úÏÑ† */}
                <HStack justifyContent="space-between">
                  <Text fontSize="18" color="#666">ÏßÑÌñâ ÏÉÅÌÉú</Text>
                  <Badge
                      colorScheme={progress.isOnTrack ? "green" : "orange"}
                      variant="subtle"
                  >
                    <Text fontSize="16" fontWeight="500">
                      {progress.isOnTrack ? "Ï†ïÏÉÅ ÏßÑÌñâÏ§ë" : "ÏßÑÎèÑ Îí§Ï≤òÏßê"}
                    </Text>
                  </Badge>
                </HStack>

                <HStack justifyContent="space-between">
                  <Text fontSize="18" color="#666">ÎÇ®ÏùÄ ÏùºÏàò</Text>
                  <Text fontSize="18" fontWeight="500">
                    {progress.remainingDays || getDaysRemaining()}Ïùº
                  </Text>
                </HStack>
              </VStack>
            </VStack>
          </Box>

          <Box mx={4} mt={4} mb={4}>
            <VStack space={3}>
              <Button
                  bg="#37C4B9"
                  _pressed={{ bg: "#2BA89E" }}
                  onPress={() => setMenuIndex(0)}
                  borderRadius="md"
                  h={12}
              >
                <Text color="white" fontSize={16} fontWeight="600">
                  Ïò§Îäò ÏùΩÍ∏∞ Í≥ÑÏÜçÌïòÍ∏∞
                </Text>
              </Button>

              <Button
                  bg="transparent"
                  borderWidth={2}
                  borderColor="#FF6B6B"
                  _pressed={{ bg: "#FFF5F5" }}
                  onPress={handleResetPlan}
                  borderRadius="md"
                  h={12}
              >
                <Text color="#FF6B6B" fontSize={16} fontWeight="600">
                  ÏùºÎèÖ Ï¥àÍ∏∞Ìôî
                </Text>
              </Button>
            </VStack>
          </Box>
        </ScrollView>
    );
  }, [planData, color.white, navigation, handleDirectReset, getPlanTypeName, calculateProgress, calculateMissedChapters, getTodayChapters, getCurrentDay, forceUpdateKey]);

  // üî• ÏàòÏ†ïÎêú ÏùºÎèÖ ÏßÑÌñâ ÌòÑÌô© Î∞ïÏä§ - ÏãúÍ∞Ñ Í∏∞Î∞ò Í≥ÑÏÇ∞ ÏßÄÏõê
  const renderProgressIndicator = useCallback((planData: any) => {
    // Ïò§ÎäòÏùò Í≥ÑÌöç Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ (ÌÜµÌï©Îêú Î∞©Ïãù)
    const getTodayPlanInfo = () => {
      // ÏãúÍ∞Ñ Í∏∞Î∞ò Í≥ÑÌöçÏù¥Í≥† dailyPlanÏù¥ ÏûàÎäî Í≤ΩÏö∞
      if (planData.isTimeBasedCalculation && planData.dailyPlan && planData.dailyPlan.length > 0) {
        const currentDay = getCurrentDay(planData.startDate);

        console.log(`
        üì± Ïò§Îäò Î™©Ìëú Í≥ÑÏÇ∞
        - ÏãúÏûëÏùº: ${planData.startDate}
        - ÌòÑÏû¨ ÏùºÏ∞®: ${currentDay}ÏùºÏ∞®
        - dailyPlan Í∏∏Ïù¥: ${planData.dailyPlan.length}
      `);

        // ÏùºÏ∞®Î°ú Ïò§ÎäòÏùò Í≥ÑÌöç Ï∞æÍ∏∞
        const todayPlan = planData.dailyPlan.find((day: any) => day.day === currentDay);

        if (todayPlan) {
          console.log(`‚úÖ ${currentDay}ÏùºÏ∞® Í≥ÑÌöç Ï∞æÏùå:`, {
            Ïû•Ïàò: todayPlan.actualChapterCount || todayPlan.chapters.length,
            ÏãúÍ∞Ñ: todayPlan.formattedTime
          });

          return {
            chapters: todayPlan.actualChapterCount || todayPlan.chapters.length,
            time: todayPlan.formattedTime || `${todayPlan.totalMinutes}Î∂Ñ`,
            isActual: true
          };
        } else {
          console.log(`‚ö†Ô∏è ${currentDay}ÏùºÏ∞® Í≥ÑÌöçÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå`);

          // Í≥ÑÌöçÏù¥ ÎÅùÎÇ¨Í±∞ÎÇò ÏãúÏûë Ï†ÑÏù∏ Í≤ΩÏö∞ Ï≤òÎ¶¨
          if (currentDay > planData.totalDays) {
            return {
              chapters: 0,
              time: 'ÏôÑÎ£å',
              isActual: true
            };
          } else if (currentDay < 1) {
            return {
              chapters: 0,
              time: 'ÏãúÏûë Ï†Ñ',
              isActual: true
            };
          }
        }
      }

      // Í∏∞Î≥∏Í∞í - getTodayChapters ÏÇ¨Ïö©
      const todayChapters = getTodayChapters(planData);
      const chapters = todayChapters.length || planData.chaptersPerDay || Math.ceil(planData.totalChapters / planData.totalDays);
      const minutes = planData.minutesPerDay || planData.targetMinutesPerDay || Math.round(planData.minutesPerDayExact) || Math.round(chapters * 4.5);

      return {
        chapters: chapters,
        time: formatDailyTarget ? formatDailyTarget(minutes) : `${minutes}Î∂Ñ`,
        isActual: false
      };
    };

    const todayInfo = getTodayPlanInfo();

    console.log(`
    üì± UI ÌëúÏãú Ï†ïÎ≥¥ (ÏµúÏ¢Ö)
    - Ïò§Îäò Î™©Ìëú: ${todayInfo.chapters}Ïû• / ${todayInfo.time}
    - Ïã§Ï†ú Í≥ÑÌöç: ${todayInfo.isActual}
  `);

    return (
        <Box bg="#E8F8F7" mx={4} mt={4} p={4} borderRadius="md">
          <VStack space={3}>
            {/* ÏÉÅÎã® ÏÑ§Î™Ö */}
            <Text fontSize="16" color="#666" textAlign="center">
              {getPlanTypeDescription(planData.planType)}
            </Text>

            {/* Ï§ëÏïô ÏùºÎèÖ ÏßÑÌñâÏ§ë ÌÖçÏä§Ìä∏ */}
            <HStack justifyContent="center" alignItems="center" space={2}>
              <Text fontSize="19" color="#37C4B9">üìñ</Text>
              <Text fontSize="19" color="#37C4B9" fontWeight="600">
                {getPlanTypeName(planData.planType)} ÏùºÎèÖ ÏßÑÌñâÏ§ë
              </Text>
            </HStack>

            {/* ÌïòÎã® Í∏∞Í∞Ñ Ï†ïÎ≥¥ */}
            <VStack space={1}>
              <HStack justifyContent="space-between" alignItems="center">
                <Text fontSize="18" color="#666">Ï¥ù Í∏∞Í∞Ñ :</Text>
                <HStack alignItems="baseline">
                  <Text fontSize="16" color="#666">
                    {dayjs(planData.startDate).format('YY.MM.DD')} ~ {dayjs(planData.endDate || planData.targetDate).format('YY.MM.DD')}
                  </Text>
                  <Text fontSize="18" color="#37C4B9" fontWeight="600" ml={2}>
                    {planData.totalDays}Ïùº
                  </Text>
                </HStack>
              </HStack>

              {/* ÌïòÎ£® Î™©Ìëú ÌëúÏãú - ÌÜµÌï©Îêú Ï†ïÎ≥¥ ÏÇ¨Ïö© */}
              <HStack justifyContent="space-between" alignItems="center">
                <Text fontSize="18" color="#666">
                  {todayInfo.isActual ? "Ïò§Îäò Î™©Ìëú :" : "ÌïòÎ£® Î™©Ìëú :"}
                </Text>
                <HStack alignItems="baseline">
                  <Text fontSize="18" color="#37C4B9" fontWeight="700">
                    {todayInfo.chapters}Ïû•
                  </Text>
                  <Text fontSize="18" color="#37C4B9" ml={1} fontWeight="700">
                    / {todayInfo.time.toString().split('.')[0].replace('', '')}
                  </Text>
                </HStack>
              </HStack>
            </VStack>
          </VStack>
        </Box>
    );
  }, [getPlanTypeName, getPlanTypeDescription, getTodayChapters, getCurrentDay, formatDailyTarget]);

  // Ïª¥Ìè¨ÎÑåÌä∏ Î†åÎçîÎßÅ
  const renderContent = useCallback(() => {
    if (isLoading) {
      return (
          <Box flex={1} justifyContent="center" alignItems="center">
            <Text>Î°úÎî© Ï§ë...</Text>
          </Box>
      );
    }

    const currentMenuName = safeMenuList[menuIndex];

    if (currentMenuName === "ÏÑ§Ï†ï") {
      return <SettingSidePage
          key={`setting-${forceUpdateKey}`}
          readState={mark}
          onTrigger={handleChangeUpdateData}
      />;
    }

    if (currentMenuName === "ÏßÑÎèÑ") {
      return <ProgressView key={`progress-${forceUpdateKey}`} />;
    }

    if (planData && menuIndex === 0) {
      const progressIndicator = renderProgressIndicator(planData);

      switch (planData.planType) {
        case 'full_bible':
          return (
              <ScrollView
                  key={`full-bible-${forceUpdateKey}-${mark?.length || 0}`}
                  style={{ backgroundColor: color.white }}
              >
                {progressIndicator}
                <Box>
                  {isFocused && mark && (
                      <Old
                          key={`plan-old-${forceUpdateKey}-${mark?.length || 0}`}
                          readState={mark}
                          menuIndex={menuIndex}
                      />
                  )}
                </Box>
                <Box>
                  {isFocused && mark && (
                      <New
                          key={`plan-new-${forceUpdateKey}-${mark?.length || 0}`}
                          readState={mark}
                          menuIndex={menuIndex}
                      />
                  )}
                </Box>
              </ScrollView>
          );

        case 'old_testament':
          return (
              <ScrollView
                  key={`old-testament-${forceUpdateKey}-${mark?.length || 0}`}
                  style={{ backgroundColor: color.white }}
              >
                {progressIndicator}
                {isFocused && mark && (
                    <Old
                        key={`old-only-${forceUpdateKey}-${mark?.length || 0}`}
                        readState={mark}
                        menuIndex={menuIndex}
                    />
                )}
              </ScrollView>
          );

        case 'new_testament':
          return (
              <ScrollView
                  key={`new-testament-${forceUpdateKey}-${mark?.length || 0}`}
                  style={{ backgroundColor: color.white }}
              >
                {progressIndicator}
                {isFocused && mark && (
                    <New
                        key={`new-only-${forceUpdateKey}-${mark?.length || 0}`}
                        readState={mark}
                        menuIndex={menuIndex}
                    />
                )}
              </ScrollView>
          );

        case 'pentateuch':
          return (
              <ScrollView
                  key={`pentateuch-${forceUpdateKey}-${mark?.length || 0}`}
                  style={{ backgroundColor: color.white }}
              >
                {progressIndicator}
                {isFocused && mark && (
                    <Old
                        key={`pentateuch-view-${forceUpdateKey}-${mark?.length || 0}`}
                        readState={mark}
                        menuIndex={menuIndex}
                        filterBooks={[1, 2, 3, 4, 5]}
                    />
                )}
              </ScrollView>
          );

        case 'psalms':
          return (
              <ScrollView
                  key={`psalms-${forceUpdateKey}-${mark?.length || 0}`}
                  style={{ backgroundColor: color.white }}
              >
                {progressIndicator}
                {isFocused && mark && (
                    <Old
                        key={`psalms-view-${forceUpdateKey}-${mark?.length || 0}`}
                        readState={mark}
                        menuIndex={menuIndex}
                        filterBooks={[19]}
                    />
                )}
              </ScrollView>
          );

        default:
          return (
              <Box flex={1} justifyContent="center" alignItems="center">
                <Text>Ïïå Ïàò ÏóÜÎäî ÏùºÎèÖ ÌÉÄÏûÖÏûÖÎãàÎã§.</Text>
              </Box>
          );
      }
    }

    if (currentMenuName === "Íµ¨ÏïΩ") {
      return (
          <ScrollView
              key={`old-${forceUpdateKey}-${mark?.length || 0}`}
              style={{ backgroundColor: color.white }}
          >
            {isFocused && mark && (
                <Old
                    key={`old-${forceUpdateKey}-${mark?.length || 0}`}
                    readState={mark}
                    menuIndex={menuIndex}
                />
            )}
          </ScrollView>
      );
    }

    if (currentMenuName === "Ïã†ÏïΩ") {
      return (
          <ScrollView
              key={`new-${forceUpdateKey}-${mark?.length || 0}`}
              style={{ backgroundColor: color.white }}
          >
            {isFocused && mark && (
                <New
                    key={`new-${forceUpdateKey}-${mark?.length || 0}`}
                    readState={mark}
                    menuIndex={menuIndex}
                />
            )}
          </ScrollView>
      );
    }

    return null;
  }, [isLoading, safeMenuList, menuIndex, mark, planData, forceUpdateKey, color.white, handleChangeUpdateData, isFocused, ProgressView, renderProgressIndicator]);

  useEffect(() => {
    console.log('üîÑ ReadingBibleScreen Ï†ÑÏó≠ ÏÉàÎ°úÍ≥†Ïπ® ÏΩúÎ∞± Îì±Î°ù');
    registerGlobalRefreshCallback(handleGlobalRefresh);

    return () => {
      console.log('üîÑ ReadingBibleScreen Ï†ÑÏó≠ ÏÉàÎ°úÍ≥†Ïπ® ÏΩúÎ∞± Ìï¥Ï†ú');
      unregisterGlobalRefreshCallback();
    };
  }, [registerGlobalRefreshCallback, unregisterGlobalRefreshCallback, handleGlobalRefresh]);

  useFocusEffect(
      useCallback(() => {
        console.log('üéØ ReadingBibleScreen Ìè¨Ïª§Ïä§ - Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏãúÏûë');
        updateMenuAndData();
        loadReadingState();

        return () => {
          console.log('üéØ ReadingBibleScreen Ìè¨Ïª§Ïä§ Ìï¥Ï†ú');
        };
      }, [updateMenuAndData, loadReadingState])
  );

  return (
      <View style={styles.container}>
        <BackHeaderLayout title="ÏÑ±Í≤ΩÏùºÎèÖ" />

        <Tabs
            menus={safeMenuList}
            onSelectHandler={handleMenuChange}
            selectedIndex={menuIndex}
        />

        {renderContent()}

        <View style={styles.adContainer}>
          <BannerAdMain />
        </View>

        <FooterLayout />
      </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#f5f5f5",
  },
  adContainer: {
    marginTop: 10,
    marginBottom: 10,
    justifyContent: "center",
    alignItems: "center",
  },
});
import React, { useEffect, useRef, useState, useCallback } from "react";
import {
    FlatList,
    FlatListProps,
    Platform,
    StyleProp,
    StyleSheet,
    View,
    ViewStyle,
} from "react-native";
import TrackPlayer, { Event, State, useTrackPlayerEvents } from 'react-native-track-player';
import { Toast } from "react-native-toast-message/lib/src/Toast";
import { defaultStorage } from "../../../utils/mmkv";
import ConectionPageBar from "../pagebar/connec";
import BannerAdMain from "../../../adforus/BannerAdMain";
import { bibleSetting, defineSQL, fetchSql } from '../../../utils';
import { useBibleReading } from '../../../utils/useBibleReading';

interface Props extends FlatListProps<any> {
    style?: StyleProp<ViewStyle>;
    contentContainerStyle?: StyleProp<ViewStyle>;
    onRefresh?: () => Promise<any>;
    onPressforward: any;
    onPressNext: any;
    isPlaying: any;
    setIsPlaying: any;
    autoPlay: any;
    setAutoPlay: any;
    onReadStatusChange?: (book: number, chapter: number, isRead: boolean) => void;
    isAutoProgressEnabled?: boolean;
    sound?: boolean;
}

const ConectionContainerFlatList = ({
                                        style,
                                        contentContainerStyle,
                                        onRefresh,
                                        onPressforward,
                                        onPressNext,
                                        isPlaying,
                                        setIsPlaying,
                                        autoPlay,
                                        setAutoPlay,
                                        onReadStatusChange,
                                        isAutoProgressEnabled = true,
                                        sound = false,
                                        ...rest
                                    }: Props) => {
    const scrollRef = useRef<FlatList>(null);
    const latlon = defaultStorage.getString("latlon")?.split("|");
    const latData = latlon?.[0] ?? 0;
    const lonData = latlon?.[1] ?? 0;
    const [adKey, setAdKey] = useState(0);
    const BOOK = defaultStorage.getNumber("bible_book_connec") ?? 1;
    const JANG = defaultStorage.getNumber("bible_jang_connec") ?? 1;

    // ÏùΩÍ∏∞ ÏÉÅÌÉú Í¥ÄÎ¶¨Î•º ÏúÑÌïú hook
    const {
        isChapterReadSync,
        markChapterAsRead,
        markChapterAsUnread,
        planData,
        updateReadingTableCache,
        loadReadingTableData
    } = useBibleReading();

    // ÏûêÎèô ÏßÑÌñâ Ï≤òÎ¶¨ Ï§ë ÏÉÅÌÉú Î∞è Ïù¥Ï†Ñ ÏÉÅÌÉú Ï∂îÏ†Å
    const [isAutoProcessing, setIsAutoProcessing] = useState(false);
    const [previousState, setPreviousState] = useState<State | null>(null);
    const autoProcessingRef = useRef(false);

    useEffect(() => {
        scrollRef.current &&
        scrollRef.current.scrollToOffset({ offset: 0, animated: false });
    }, [BOOK, JANG]);

    // Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏ Ïãú ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    useEffect(() => {
        console.log(`üìö ConectionContainer Component mounted/changed: ${BOOK}:${JANG}`);
        console.log(`üìä ConectionContainer AutoProgress: ${isAutoProgressEnabled}, Sound: ${sound}`);

        setTimeout(() => {
            setIsAutoProcessing(false);
            autoProcessingRef.current = false;
            console.log('üîÑ ConectionContainer: Force reset processing flags on page change');
        }, 100);
        setPreviousState(null);
    }, [BOOK, JANG, isAutoProgressEnabled, sound]);

    // TrackPlayer Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
    useTrackPlayerEvents([
        Event.PlaybackState,
        Event.PlaybackQueueEnded,
        Event.PlaybackTrackChanged
    ], async (event) => {
        console.log(`üéµ ConectionContainer TrackPlayer Event: ${event.type}`, event);

        // ÏûêÎèô ÏßÑÌñâÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÍ±∞ÎÇò Ïò§ÎîîÏò§Í∞Ä Í∫ºÏ†∏ÏûàÏúºÎ©¥ Î¶¨ÌÑ¥
        if (!isAutoProgressEnabled || !sound) {
            console.log(`‚ùå ConectionContainer: Auto progress disabled: autoProgress=${isAutoProgressEnabled}, sound=${sound}`);
            return;
        }

        // PlaybackQueueEndedÎäî ÏµúÍ≥† Ïö∞ÏÑ†ÏàúÏúÑ Ïù¥Î≤§Ìä∏Î°ú Ï≤òÎ¶¨
        if (event.type === Event.PlaybackQueueEnded) {
            console.log('üèÅ ConectionContainer: PlaybackQueueEnded - forcing auto progress (HIGH PRIORITY)');

            if (isAutoProcessing || autoProcessingRef.current) {
                console.log('‚ö†Ô∏è ConectionContainer: Overriding existing processing for critical queue ended event');
                setIsAutoProcessing(false);
                autoProcessingRef.current = false;

                setTimeout(async () => {
                    await handleAutoProgress();
                }, 200);
            } else {
                await handleAutoProgress();
            }
            return;
        }

        // Îã§Î•∏ Ïù¥Î≤§Ìä∏Îì§ÏùÄ Ï≤òÎ¶¨ Ï§ëÏù¥Î©¥ Ïä§ÌÇµ
        if (isAutoProcessing || autoProcessingRef.current) {
            console.log(`‚ö†Ô∏è ConectionContainer: Skipping ${event.type} - processing in progress`);
            return;
        }

        switch (event.type) {
            case Event.PlaybackState:
                console.log(`üéµ ConectionContainer: Playback state: ${event.state}, Previous: ${previousState}`);
                setPreviousState(event.state);

                if (event.state === State.Ended) {
                    console.log('üéØ ConectionContainer: Audio playback ended - triggering auto progress');
                    await handleAutoProgress();
                }
                break;

            case Event.PlaybackTrackChanged:
                console.log('üîÑ ConectionContainer: Track changed:', event);
                if (event.track === null && previousState === State.Ended) {
                    console.log('üéØ ConectionContainer: Track changed to null after completion - triggering auto progress');
                    setTimeout(async () => {
                        if (!isAutoProcessing && !autoProcessingRef.current) {
                            await handleAutoProgress();
                        }
                    }, 300);
                }
                break;
        }
    });

    // ÏûêÎèô ÏßÑÌñâ Î°úÏßÅ
    const handleAutoProgress = useCallback(async () => {
        if (isAutoProcessing || autoProcessingRef.current) {
            console.log('‚ö†Ô∏è ConectionContainer: Auto progress already in progress, skipping...');
            return;
        }

        console.log(`üöÄ ConectionContainer: Starting auto progress for ${BOOK}:${JANG}`);

        setIsAutoProcessing(true);
        autoProcessingRef.current = true;

        try {

            // 2. ÏßßÏùÄ ÎåÄÍ∏∞ (ÏÇ¨Ïö©ÏûêÍ∞Ä Î©îÏãúÏßÄÎ•º Î≥º Ïàò ÏûàÎèÑÎ°ù)
            await new Promise(resolve => setTimeout(resolve, 800));

            // 3. ÌòÑÏû¨ Ïû•ÏùÑ ÏùΩÏóàÏùåÏúºÎ°ú ÏûêÎèô Ï≤¥ÌÅ¨
            console.log('üìñ ConectionContainer: Marking chapter as read...');
            await markCurrentChapterAsRead();
            

            // 5. Ïû†Ïãú ÎåÄÍ∏∞ ÌõÑ Îã§Ïùå Ïû•ÏúºÎ°ú Ïù¥Îèô
            await new Promise(resolve => setTimeout(resolve, 600));

            console.log('‚è≠Ô∏è ConectionContainer: Moving to next chapter...');
            handleAutoNext();

            console.log('‚úÖ ConectionContainer: Auto progress completed successfully');

        } catch (error) {
            console.error('‚ùå ConectionContainer: Auto progress error:', error);
            Toast.show({
                type: "error",
                text1: "ÏûêÎèô ÏßÑÌñâ Ïò§Î•ò",
                text2: "ÏàòÎèôÏúºÎ°ú ÏùΩÏóàÏùå Ï≤¥ÌÅ¨ ÌõÑ Îã§Ïùå Ïû•ÏúºÎ°ú Ïù¥ÎèôÌï¥Ï£ºÏÑ∏Ïöî.",
                visibilityTime: 3000,
                position: "top",
            });
        } finally {
            console.log('üîÑ ConectionContainer: Resetting auto progress states');
            setIsAutoProcessing(false);
            autoProcessingRef.current = false;
            setPreviousState(null);
        }
    }, [BOOK, JANG]);

    // ÌòÑÏû¨ Ïû•ÏùÑ ÏùΩÏóàÏùåÏúºÎ°ú ÌëúÏãúÌïòÎäî Ìï®Ïàò
    const markCurrentChapterAsRead = useCallback(async () => {
        try {
            console.log(`üìù ConectionContainer: Marking chapter ${BOOK}:${JANG} as read`);

            const settingSelectSql = `${defineSQL(['read'], 'SELECT', 'reading_table', {
                WHERE: { BOOK: '?', JANG: '?' }
            })}`;

            const settingInsertSql = `${defineSQL(
                ['book', 'jang', 'read', 'time'],
                'INSERT',
                'reading_table',
                {}
            )}`;

            const settingUpdateSql = `${defineSQL(
                ['read', 'time'],
                'UPDATE',
                'reading_table',
                {
                    WHERE: { BOOK, JANG }
                }
            )}`;

            const result = await fetchSql(bibleSetting, settingSelectSql, [BOOK, JANG], 0);

            if (result) {
                await fetchSql(bibleSetting, settingUpdateSql, [
                    'true',
                    String(new Date())
                ]);
                console.log('‚úÖ ConectionContainer: Updated existing reading record');
            } else {
                await fetchSql(bibleSetting, settingInsertSql, [
                    BOOK,
                    JANG,
                    'true',
                    String(new Date())
                ]);
                console.log('‚úÖ ConectionContainer: Created new reading record');
            }

            updateReadingTableCache(BOOK, JANG, true);

            if (planData) {
                await markChapterAsRead(BOOK, JANG);
                console.log('‚úÖ ConectionContainer: Updated plan data');
            }

            if (onReadStatusChange) {
                onReadStatusChange(BOOK, JANG, true);
                console.log('‚úÖ ConectionContainer: Notified parent component');
            }

            console.log(`‚úÖ ConectionContainer: Successfully marked chapter ${BOOK}:${JANG} as read`);

        } catch (error) {
            console.error('‚ùå ConectionContainer: Error marking chapter as read:', error);
            throw error;
        }
    }, [BOOK, JANG, updateReadingTableCache, planData, markChapterAsRead, onReadStatusChange]);

    // ÏûêÎèô Îã§Ïùå Ïû• Ïù¥Îèô Ìï®Ïàò
    const handleAutoNext = useCallback(() => {
        try {
            console.log(`‚è≠Ô∏è ConectionContainer: Auto-navigating to next chapter from ${BOOK}:${JANG}`);

            setAdKey((prev) => prev + 1);
            onPressNext(JANG);

            console.log('‚úÖ ConectionContainer: Successfully initiated navigation to next chapter');

        } catch (error) {
            console.error('‚ùå ConectionContainer: Error auto-navigating to next chapter:', error);
        }
    }, [BOOK, JANG, onPressNext]);

    const handlePressNext = (...args: any[]) => {
        setAdKey((prev) => prev + 1);
        onPressNext(...args);
    };

    const handlePressForward = (...args: any[]) => {
        setAdKey((prev) => prev + 1);
        onPressforward(...args);
    };

    // ÎîîÎ≤ÑÍπÖÏö© ÏÉÅÌÉú Î°úÍπÖ
    useEffect(() => {
        console.log(`üìä ConectionContainer Current state - Book: ${BOOK}, Chapter: ${JANG}, AutoProgress: ${isAutoProgressEnabled}, Sound: ${sound}, Processing: ${isAutoProcessing}`);
    }, [BOOK, JANG, isAutoProgressEnabled, sound, isAutoProcessing]);

    return (
        <View style={[styles.container, style]}>
            {Platform.OS === "android" && (
                <View style={{ marginTop: 20 }}>
                    <BannerAdMain key={adKey} />
                </View>
            )}

            <FlatList
                contentInsetAdjustmentBehavior="always"
                ref={scrollRef}
                contentContainerStyle={[
                    styles.flexGrow,
                    contentContainerStyle,
                    { paddingTop: 30, paddingBottom: 30 },
                ]}
                scrollEventThrottle={200}
                showsVerticalScrollIndicator={false}
                showsHorizontalScrollIndicator={false}
                {...rest}
            />

            <ConectionPageBar
                onPressforward={handlePressForward}
                onPressNext={handlePressNext}
                isPlaying={isPlaying}
                setIsPlaying={setIsPlaying}
                autoPlay={autoPlay}
                setAutoPlay={setAutoPlay}
                onReadStatusChange={onReadStatusChange}
            />
        </View>
    );
};

const styles = StyleSheet.create({
    container: {
        flex: 1,
        backgroundColor: "white",
        position: "relative",
    },
    flexGrow: {
        flexGrow: 1,
    },
    flex: {
        flex: 1,
    },
});

export default ConectionContainerFlatList;